=================================================
Simulating violation: w-bf-cc-df-ec [stack buffer overrun]
Simulation graph has 21 edges
27 simulations recorded

CHARACTERISTICS
---------------

Exploitability(avg) = 0.222656250103682
Exploitability(max) = 1
Exploitability(min) = 9.09494701772928E-13


CONFIGURATION
-------------

Hardware profile: x86/x86_pae

AddressBits=32
ArchitectureFamily=I386
NXPolicy=On
SMEPPolicy=NotSupported


OperatingSystem profile: windows/seven/rtm/32bit

UserSEHOPPolicy=OptIn
UserSafeSEHPolicy=On
UserASLRPolicyBottomUpHighEntropy=NotSupported
UserPointerEncodingUEF=True
UserPointerEncodingPEBFastLockRoutine=True
UserPointerEncodingHeapCommitRoutine=True
AddressBits=32
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC81
DefaultStackProtectionEntropyBits=32
KernelSMEPPolicy=NotSupported
KernelNullDereferencePreventionPolicy=NotSupported
KernelPoolPolicies.HeapFreeSafeUnlinking=On
KernelPoolPolicies.HeapTerminateOnCorruption=NotSupported
KernelPoolPolicies.HeapAllocationOrderRandomization=NotSupported
KernelPoolPolicies.HeapBlockHeaderCookies=NotSupported
KernelPoolPolicies.HeapBlockHeaderEncryption=NotSupported
KernelPoolPolicies.HeapPreventFreeHeapBase=NotSupported
KernelPoolPolicies.HeapBusyBlockIntegrityCheck=NotSupported
KernelPoolPolicies.HeapSegmentReserveGuardPage=NotSupported
KernelPoolPolicies.HeapLargeAllocationAlignment=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithPointerKey=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
KernelPoolPolicies.KernelPoolQuotaPointerEncoding=NotSupported
KernelPoolPolicies.KernelPoolLookasideListCookie=NotSupported
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=NotSupported
MemoryRegionNXPolicy.KernelNonPagedPool=NotSupported
MemoryRegionNXPolicy.KernelSessionPool=NotSupported
MemoryRegionNXPolicy.KernelPageTablePages=NotSupported
MemoryRegionNXPolicy.KernelDriverImage=NotSupported
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=NotSupported
MemoryRegionNXPolicy.KernelSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelSystemPTE=NotSupported
MemoryRegionNXPolicy.KernelSystemCache=NotSupported
MemoryRegionNXPolicy.KernelPFNDatabase=NotSupported
MemoryRegionNXPolicy.KernelHALReserved=NotSupported
MemoryRegionNXPolicy.UserProcessHeap=OptIn
MemoryRegionNXPolicy.UserThreadStack=OptIn
MemoryRegionNXPolicy.UserPEB=OptIn
MemoryRegionNXPolicy.UserTEB=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBU=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=OptIn
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=OptIn
MemoryRegionNXPolicy.UserExeImageCode=OptIn
MemoryRegionNXPolicy.UserExeImageData=OptIn
MemoryRegionNXPolicy.UserDllImageBase=OptIn
MemoryRegionNXPolicy.UserDllImageCode=OptIn
MemoryRegionNXPolicy.UserDllImageData=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageData=OptIn
MemoryRegionNXPolicy.UserSharedUserData=OptIn
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=OptIn
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=NotSupported
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=OptIn
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=OptIn
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionASLREntropyBits.KernelInitialThreadStack=0
MemoryRegionASLREntropyBits.KernelThreadStack=0
MemoryRegionASLREntropyBits.KernelPagedPool=0
MemoryRegionASLREntropyBits.KernelNonPagedPool=0
MemoryRegionASLREntropyBits.KernelSessionPool=0
MemoryRegionASLREntropyBits.KernelPageTablePages=0
MemoryRegionASLREntropyBits.KernelDriverImage=4
MemoryRegionASLREntropyBits.KernelExeImage=5
MemoryRegionASLREntropyBits.KernelHyperspace=0
MemoryRegionASLREntropyBits.KernelPCR=0
MemoryRegionASLREntropyBits.KernelSharedUserData=0
MemoryRegionASLREntropyBits.KernelSystemPTE=0
MemoryRegionASLREntropyBits.KernelSystemCache=0
MemoryRegionASLREntropyBits.KernelPFNDatabase=0
MemoryRegionASLREntropyBits.KernelHALReserved=0
MemoryRegionASLREntropyBits.UserProcessHeap=5
MemoryRegionASLREntropyBits.UserThreadStack=14
MemoryRegionASLREntropyBits.UserPEB=4
MemoryRegionASLREntropyBits.UserTEB=4
MemoryRegionASLREntropyBits.UserVirtualAllocBU=0
MemoryRegionASLREntropyBits.UserVirtualAllocBUHE=0
MemoryRegionASLREntropyBits.UserVirtualAllocTD=0
MemoryRegionASLREntropyBits.UserJITCode=0
MemoryRegionASLREntropyBits.UserExeImageBase=8
MemoryRegionASLREntropyBits.UserExeImageCode=8
MemoryRegionASLREntropyBits.UserExeImageData=8
MemoryRegionASLREntropyBits.UserDllImageBase=8
MemoryRegionASLREntropyBits.UserDllImageCode=8
MemoryRegionASLREntropyBits.UserDllImageData=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageBase=0
MemoryRegionASLREntropyBits.UserForceRelocatedImageCode=0
MemoryRegionASLREntropyBits.UserForceRelocatedImageData=0
MemoryRegionASLREntropyBits.UserSharedUserData=0
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=OptIn
UserHeapPolicy.HeapAllocationOrderRandomization=NotSupported
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=NotSupported
UserHeapPolicy.HeapBusyBlockIntegrityCheck=NotSupported
UserHeapPolicy.HeapSegmentReserveGuardPage=NotSupported
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=On
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Application profile: windows/ie/ie8/32bit

UserSEHOPPolicy=OptIn
UserASLRPolicyBottomUpHighEntropy=
AddressBits=32
KernelApplication=False
NXPermanent=
HeapAllocator=
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC81
DefaultStackProtectionEntropyBits=32
RestrictAutomaticRestarts=
CanInitializeContentViaHeapSpray=True
CanInitializeCodeViaJIT=False
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=On
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=NotSupported
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=On
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=On
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=NotSupported
MemoryRegionNXPolicy.KernelNonPagedPool=NotSupported
MemoryRegionNXPolicy.KernelSessionPool=NotSupported
MemoryRegionNXPolicy.KernelPageTablePages=NotSupported
MemoryRegionNXPolicy.KernelDriverImage=NotSupported
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=NotSupported
MemoryRegionNXPolicy.KernelSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelSystemPTE=NotSupported
MemoryRegionNXPolicy.KernelSystemCache=NotSupported
MemoryRegionNXPolicy.KernelPFNDatabase=NotSupported
MemoryRegionNXPolicy.KernelHALReserved=NotSupported
MemoryRegionNXPolicy.UserProcessHeap=On
MemoryRegionNXPolicy.UserThreadStack=On
MemoryRegionNXPolicy.UserPEB=On
MemoryRegionNXPolicy.UserTEB=On
MemoryRegionNXPolicy.UserVirtualAllocBU=On
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=On
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=On
MemoryRegionNXPolicy.UserExeImageCode=On
MemoryRegionNXPolicy.UserExeImageData=On
MemoryRegionNXPolicy.UserDllImageBase=On
MemoryRegionNXPolicy.UserDllImageCode=On
MemoryRegionNXPolicy.UserDllImageData=On
MemoryRegionNXPolicy.UserForceRelocatedImageBase=On
MemoryRegionNXPolicy.UserForceRelocatedImageCode=On
MemoryRegionNXPolicy.UserForceRelocatedImageData=On
MemoryRegionNXPolicy.UserSharedUserData=On
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=On
UserHeapPolicy.HeapAllocationOrderRandomization=NotSupported
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=NotSupported
UserHeapPolicy.HeapBusyBlockIntegrityCheck=NotSupported
UserHeapPolicy.HeapSegmentReserveGuardPage=NotSupported
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=On
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Violation profile: w-bf-cc-df-ec

Method=Write
BaseState=Fixed
BaseRegionType=Stack
ContentSrcState=Controlled
ContentDstState=Unknown
ContentDataType=
ContentDataTypeName=
ContentContainerDataType=
ContentContainerTypeName=
DisplacementState=Fixed
DisplacementInitialOffset=PostAdjacent
ExtentState=Controlled
AddressingMode=Relative
Direction=Forward
ControlTransferMethod=
Address=
Locality=Unspecified
AccessRequirement=Unspecified
ExecutionDomain=Unspecified
CrashDumpFile=
SourceFile=
SourceLines=
TraceFile=
TracePositions=
FunctionStackProtectionEnabled=True
FunctionStackProtectionVersion=GS_VC81
FunctionStackProtectionEntropyBits=32
TransitiveExecuteListIsComplete=
TransitiveReadListIsComplete=
TransitiveWriteListIsComplete=




SIMULATIONS
-----------

===============

Simulation exploitability: 1

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (pure)                                ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (pure)                                ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [execute ROP (pure)                                ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to disable NX for process)     ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (pure)                                ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (pure)                                ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> load non-ASLR image                 -> x-b?-cf
 x-b?-cf                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> load non-ASLR image                 -> x-b?-cf
 x-b?-cf                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (pure)                                ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> load non-ASLR and non-safeSEH image -> x-b?-cf
 x-b?-cf                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> load non-ASLR and non-safeSEH image -> x-b?-cf
 x-b?-cf                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (pure)                                ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> load non-ASLR image                 -> x-b?-cf
 x-b?-cf                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 2.3283064365387E-10

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> load non-ASLR and non-safeSEH image -> x-b?-cf
 x-b?-cf                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (pure)                                ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to disable NX for process)     ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (pure)                                ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to disable NX for process)     ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode


Simulation finished, press any key.
=================================================
Simulating violation: w-bf-cc-df-ec [stack buffer overrun]
Simulation graph has 21 edges
9 simulations recorded

CHARACTERISTICS
---------------

Exploitability(avg) = 0.00130208333393966
Exploitability(max) = 0.00390625
Exploitability(min) = 9.09494701772928E-13


CONFIGURATION
-------------

Hardware profile: x86/x86_pae

AddressBits=32
ArchitectureFamily=I386
NXPolicy=On
SMEPPolicy=NotSupported


OperatingSystem profile: windows/eight/rtm/32bit

UserSEHOPPolicy=OptIn
UserSafeSEHPolicy=On
UserASLRPolicyBottomUpHighEntropy=OptIn
UserPointerEncodingUEF=True
UserPointerEncodingPEBFastLockRoutine=True
UserPointerEncodingHeapCommitRoutine=True
AddressBits=32
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC10
DefaultStackProtectionEntropyBits=32
KernelSMEPPolicy=Off
KernelNullDereferencePreventionPolicy=OptOut
KernelPoolPolicies.HeapFreeSafeUnlinking=On
KernelPoolPolicies.HeapTerminateOnCorruption=NotSupported
KernelPoolPolicies.HeapAllocationOrderRandomization=NotSupported
KernelPoolPolicies.HeapBlockHeaderCookies=NotSupported
KernelPoolPolicies.HeapBlockHeaderEncryption=NotSupported
KernelPoolPolicies.HeapPreventFreeHeapBase=NotSupported
KernelPoolPolicies.HeapBusyBlockIntegrityCheck=NotSupported
KernelPoolPolicies.HeapSegmentReserveGuardPage=NotSupported
KernelPoolPolicies.HeapLargeAllocationAlignment=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithPointerKey=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
KernelPoolPolicies.KernelPoolQuotaPointerEncoding=On
KernelPoolPolicies.KernelPoolLookasideListCookie=On
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=On
MemoryRegionNXPolicy.KernelNonPagedPool=On
MemoryRegionNXPolicy.KernelSessionPool=NotSupported
MemoryRegionNXPolicy.KernelPageTablePages=On
MemoryRegionNXPolicy.KernelDriverImage=NotSupported
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=On
MemoryRegionNXPolicy.KernelSharedUserData=On
MemoryRegionNXPolicy.KernelSystemPTE=On
MemoryRegionNXPolicy.KernelSystemCache=On
MemoryRegionNXPolicy.KernelPFNDatabase=On
MemoryRegionNXPolicy.KernelHALReserved=On
MemoryRegionNXPolicy.UserProcessHeap=OptIn
MemoryRegionNXPolicy.UserThreadStack=OptIn
MemoryRegionNXPolicy.UserPEB=OptIn
MemoryRegionNXPolicy.UserTEB=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBU=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=OptIn
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=OptIn
MemoryRegionNXPolicy.UserExeImageCode=OptIn
MemoryRegionNXPolicy.UserExeImageData=OptIn
MemoryRegionNXPolicy.UserDllImageBase=OptIn
MemoryRegionNXPolicy.UserDllImageCode=OptIn
MemoryRegionNXPolicy.UserDllImageData=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageData=OptIn
MemoryRegionNXPolicy.UserSharedUserData=OptIn
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=OptIn
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=OptIn
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=On
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=OptIn
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=OptIn
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionASLREntropyBits.KernelInitialThreadStack=0
MemoryRegionASLREntropyBits.KernelThreadStack=0
MemoryRegionASLREntropyBits.KernelPagedPool=0
MemoryRegionASLREntropyBits.KernelNonPagedPool=0
MemoryRegionASLREntropyBits.KernelSessionPool=0
MemoryRegionASLREntropyBits.KernelPageTablePages=0
MemoryRegionASLREntropyBits.KernelDriverImage=4
MemoryRegionASLREntropyBits.KernelExeImage=5
MemoryRegionASLREntropyBits.KernelHyperspace=0
MemoryRegionASLREntropyBits.KernelPCR=0
MemoryRegionASLREntropyBits.KernelSharedUserData=0
MemoryRegionASLREntropyBits.KernelSystemPTE=0
MemoryRegionASLREntropyBits.KernelSystemCache=0
MemoryRegionASLREntropyBits.KernelPFNDatabase=0
MemoryRegionASLREntropyBits.KernelHALReserved=0
MemoryRegionASLREntropyBits.UserProcessHeap=8
MemoryRegionASLREntropyBits.UserThreadStack=8
MemoryRegionASLREntropyBits.UserPEB=8
MemoryRegionASLREntropyBits.UserTEB=8
MemoryRegionASLREntropyBits.UserVirtualAllocBU=8
MemoryRegionASLREntropyBits.UserVirtualAllocBUHE=24
MemoryRegionASLREntropyBits.UserVirtualAllocTD=8
MemoryRegionASLREntropyBits.UserJITCode=8
MemoryRegionASLREntropyBits.UserExeImageBase=8
MemoryRegionASLREntropyBits.UserExeImageCode=8
MemoryRegionASLREntropyBits.UserExeImageData=8
MemoryRegionASLREntropyBits.UserDllImageBase=8
MemoryRegionASLREntropyBits.UserDllImageCode=8
MemoryRegionASLREntropyBits.UserDllImageData=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageBase=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageCode=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageData=8
MemoryRegionASLREntropyBits.UserSharedUserData=0
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=OptIn
UserHeapPolicy.HeapAllocationOrderRandomization=On
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=On
UserHeapPolicy.HeapBusyBlockIntegrityCheck=On
UserHeapPolicy.HeapSegmentReserveGuardPage=On
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=On
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Application profile: windows/ie/ie9/32bit

UserSEHOPPolicy=On
UserASLRPolicyBottomUpHighEntropy=
AddressBits=32
KernelApplication=False
NXPermanent=
HeapAllocator=
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC10
DefaultStackProtectionEntropyBits=32
RestrictAutomaticRestarts=
CanInitializeContentViaHeapSpray=True
CanInitializeCodeViaJIT=False
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=On
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=On
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=On
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=On
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=On
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=On
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=On
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=On
MemoryRegionNXPolicy.KernelNonPagedPool=On
MemoryRegionNXPolicy.KernelSessionPool=NotSupported
MemoryRegionNXPolicy.KernelPageTablePages=On
MemoryRegionNXPolicy.KernelDriverImage=NotSupported
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=On
MemoryRegionNXPolicy.KernelSharedUserData=On
MemoryRegionNXPolicy.KernelSystemPTE=On
MemoryRegionNXPolicy.KernelSystemCache=On
MemoryRegionNXPolicy.KernelPFNDatabase=On
MemoryRegionNXPolicy.KernelHALReserved=On
MemoryRegionNXPolicy.UserProcessHeap=On
MemoryRegionNXPolicy.UserThreadStack=On
MemoryRegionNXPolicy.UserPEB=On
MemoryRegionNXPolicy.UserTEB=On
MemoryRegionNXPolicy.UserVirtualAllocBU=On
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=On
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=On
MemoryRegionNXPolicy.UserExeImageCode=On
MemoryRegionNXPolicy.UserExeImageData=On
MemoryRegionNXPolicy.UserDllImageBase=On
MemoryRegionNXPolicy.UserDllImageCode=On
MemoryRegionNXPolicy.UserDllImageData=On
MemoryRegionNXPolicy.UserForceRelocatedImageBase=On
MemoryRegionNXPolicy.UserForceRelocatedImageCode=On
MemoryRegionNXPolicy.UserForceRelocatedImageData=On
MemoryRegionNXPolicy.UserSharedUserData=On
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=On
UserHeapPolicy.HeapAllocationOrderRandomization=On
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=On
UserHeapPolicy.HeapBusyBlockIntegrityCheck=On
UserHeapPolicy.HeapSegmentReserveGuardPage=On
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=On
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Violation profile: w-bf-cc-df-ec

Method=Write
BaseState=Fixed
BaseRegionType=Stack
ContentSrcState=Controlled
ContentDstState=Unknown
ContentDataType=
ContentDataTypeName=
ContentContainerDataType=
ContentContainerTypeName=
DisplacementState=Fixed
DisplacementInitialOffset=PostAdjacent
ExtentState=Controlled
AddressingMode=Relative
Direction=Forward
ControlTransferMethod=
Address=
Locality=Unspecified
AccessRequirement=Unspecified
ExecutionDomain=Unspecified
CrashDumpFile=
SourceFile=
SourceLines=
TraceFile=
TracePositions=
FunctionStackProtectionEnabled=True
FunctionStackProtectionVersion=GS_VC10
FunctionStackProtectionEntropyBits=32
TransitiveExecuteListIsComplete=
TransitiveReadListIsComplete=
TransitiveWriteListIsComplete=




SIMULATIONS
-----------

===============

Simulation exploitability: 0.00390625

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 0.00390625 = CanFindAddress(&ImageCodeSegmentNtdll.Code)
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [call corrupted handler via exception              ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 0.00390625 = CanFindAddress(&ImageCodeSegmentNtdll.Code)
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [call corrupted handler via exception              ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 w-bf-cc-df-ec                                      -> corrupt SEH handler                 -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> call corrupted handler via exception -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt SEH handler                               ] 1 = CanTriggerException
 [corrupt SEH handler                               ] 1 = CanTriggerMemoryRead
 [call corrupted handler via exception              ] 1 = CanReadMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [call corrupted handler via exception              ] 1 = CanBypassSafeSEH
 [call corrupted handler via exception              ] 0.00390625 = CanFindAddress(&ImageCodeSegmentNtdll.Code)
 [call corrupted handler via exception              ] 1 = CanBypassSEHOP
 [call corrupted handler via exception              ] 1 = CanTriggerMemoryExecute
 [call corrupted handler via exception              ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (pure)                                ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to disable NX for process)     ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (pure)                                ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 9.09494701772928E-13

Transitions

 w-bf-cc-df-ec                                      -> corrupt stack frame pointer leading to function return -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> restore corrupted frame pointer and return from child function -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> return from function with corrupted return address -> x-b?-c?
 x-b?-c?                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt stack frame pointer leading to function return] 1 = CanTriggerMemoryRead
 [restore corrupted frame pointer and return from child function] 1 = CanPositionAtDesiredRelativeAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanReadMemoryAtAddress(&Stack.StackFramePointer)
 [restore corrupted frame pointer and return from child function] 1 = CanTriggerFunctionReturn
 [restore corrupted frame pointer and return from child function] 2.3283064365387E-10 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanPositionAtDesiredAbsoluteAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to disable NX for process)     ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode


Simulation finished, press any key.
=================================================
Simulating violation: w-bf-cc-df-ec [stack buffer overrun]
Simulation graph has 21 edges
2 simulations recorded

CHARACTERISTICS
---------------

Exploitability(avg) = 1.61558713389263E-27
Exploitability(max) = 1.61558713389263E-27
Exploitability(min) = 1.61558713389263E-27


CONFIGURATION
-------------

Hardware profile: x86/x86_pae

AddressBits=32
ArchitectureFamily=I386
NXPolicy=On
SMEPPolicy=NotSupported


OperatingSystem profile: windows/eight/rtm/64bit

UserSEHOPPolicy=OptIn
UserSafeSEHPolicy=On
UserASLRPolicyBottomUpHighEntropy=OptIn
UserPointerEncodingUEF=True
UserPointerEncodingPEBFastLockRoutine=True
UserPointerEncodingHeapCommitRoutine=True
AddressBits=64
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC10
DefaultStackProtectionEntropyBits=48
KernelSMEPPolicy=Off
KernelNullDereferencePreventionPolicy=OptOut
KernelPoolPolicies.HeapFreeSafeUnlinking=On
KernelPoolPolicies.HeapTerminateOnCorruption=NotSupported
KernelPoolPolicies.HeapAllocationOrderRandomization=NotSupported
KernelPoolPolicies.HeapBlockHeaderCookies=NotSupported
KernelPoolPolicies.HeapBlockHeaderEncryption=NotSupported
KernelPoolPolicies.HeapPreventFreeHeapBase=NotSupported
KernelPoolPolicies.HeapBusyBlockIntegrityCheck=NotSupported
KernelPoolPolicies.HeapSegmentReserveGuardPage=NotSupported
KernelPoolPolicies.HeapLargeAllocationAlignment=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithPointerKey=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
KernelPoolPolicies.KernelPoolQuotaPointerEncoding=On
KernelPoolPolicies.KernelPoolLookasideListCookie=On
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=On
MemoryRegionNXPolicy.KernelNonPagedPool=On
MemoryRegionNXPolicy.KernelSessionPool=On
MemoryRegionNXPolicy.KernelPageTablePages=On
MemoryRegionNXPolicy.KernelDriverImage=On
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=On
MemoryRegionNXPolicy.KernelSharedUserData=On
MemoryRegionNXPolicy.KernelSystemPTE=On
MemoryRegionNXPolicy.KernelSystemCache=On
MemoryRegionNXPolicy.KernelPFNDatabase=On
MemoryRegionNXPolicy.KernelHALReserved=On
MemoryRegionNXPolicy.UserProcessHeap=OptIn
MemoryRegionNXPolicy.UserThreadStack=OptIn
MemoryRegionNXPolicy.UserPEB=OptIn
MemoryRegionNXPolicy.UserTEB=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBU=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=OptIn
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=OptIn
MemoryRegionNXPolicy.UserExeImageCode=OptIn
MemoryRegionNXPolicy.UserExeImageData=OptIn
MemoryRegionNXPolicy.UserDllImageBase=OptIn
MemoryRegionNXPolicy.UserDllImageCode=OptIn
MemoryRegionNXPolicy.UserDllImageData=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageData=OptIn
MemoryRegionNXPolicy.UserSharedUserData=OptIn
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=OptIn
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=OptIn
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=On
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=OptIn
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=OptIn
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionASLREntropyBits.KernelInitialThreadStack=0
MemoryRegionASLREntropyBits.KernelThreadStack=0
MemoryRegionASLREntropyBits.KernelPagedPool=0
MemoryRegionASLREntropyBits.KernelNonPagedPool=0
MemoryRegionASLREntropyBits.KernelSessionPool=0
MemoryRegionASLREntropyBits.KernelPageTablePages=0
MemoryRegionASLREntropyBits.KernelDriverImage=4
MemoryRegionASLREntropyBits.KernelExeImage=5
MemoryRegionASLREntropyBits.KernelHyperspace=0
MemoryRegionASLREntropyBits.KernelPCR=0
MemoryRegionASLREntropyBits.KernelSharedUserData=0
MemoryRegionASLREntropyBits.KernelSystemPTE=0
MemoryRegionASLREntropyBits.KernelSystemCache=0
MemoryRegionASLREntropyBits.KernelPFNDatabase=0
MemoryRegionASLREntropyBits.KernelHALReserved=0
MemoryRegionASLREntropyBits.UserProcessHeap=24
MemoryRegionASLREntropyBits.UserThreadStack=33
MemoryRegionASLREntropyBits.UserPEB=17
MemoryRegionASLREntropyBits.UserTEB=17
MemoryRegionASLREntropyBits.UserVirtualAllocBU=24
MemoryRegionASLREntropyBits.UserVirtualAllocBUHE=24
MemoryRegionASLREntropyBits.UserVirtualAllocTD=17
MemoryRegionASLREntropyBits.UserJITCode=24
MemoryRegionASLREntropyBits.UserExeImageBase=17
MemoryRegionASLREntropyBits.UserExeImageCode=8
MemoryRegionASLREntropyBits.UserExeImageData=8
MemoryRegionASLREntropyBits.UserDllImageBase=19
MemoryRegionASLREntropyBits.UserDllImageCode=8
MemoryRegionASLREntropyBits.UserDllImageData=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageBase=24
MemoryRegionASLREntropyBits.UserForceRelocatedImageCode=24
MemoryRegionASLREntropyBits.UserForceRelocatedImageData=24
MemoryRegionASLREntropyBits.UserSharedUserData=0
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=OptOut
UserHeapPolicy.HeapAllocationOrderRandomization=On
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=On
UserHeapPolicy.HeapBusyBlockIntegrityCheck=On
UserHeapPolicy.HeapSegmentReserveGuardPage=On
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=On
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Application profile: windows/ie/ie10/64bit

UserSEHOPPolicy=OptIn
UserASLRPolicyBottomUpHighEntropy=On
AddressBits=64
KernelApplication=False
NXPermanent=
HeapAllocator=
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC10
DefaultStackProtectionEntropyBits=48
RestrictAutomaticRestarts=
CanInitializeContentViaHeapSpray=False
CanInitializeCodeViaJIT=False
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=On
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=On
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=On
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=On
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=On
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=On
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=On
MemoryRegionASLRPolicy.UserForceRelocatedImageData=On
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=On
MemoryRegionNXPolicy.KernelNonPagedPool=On
MemoryRegionNXPolicy.KernelSessionPool=On
MemoryRegionNXPolicy.KernelPageTablePages=On
MemoryRegionNXPolicy.KernelDriverImage=On
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=On
MemoryRegionNXPolicy.KernelSharedUserData=On
MemoryRegionNXPolicy.KernelSystemPTE=On
MemoryRegionNXPolicy.KernelSystemCache=On
MemoryRegionNXPolicy.KernelPFNDatabase=On
MemoryRegionNXPolicy.KernelHALReserved=On
MemoryRegionNXPolicy.UserProcessHeap=On
MemoryRegionNXPolicy.UserThreadStack=On
MemoryRegionNXPolicy.UserPEB=On
MemoryRegionNXPolicy.UserTEB=On
MemoryRegionNXPolicy.UserVirtualAllocBU=On
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=On
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=On
MemoryRegionNXPolicy.UserExeImageCode=On
MemoryRegionNXPolicy.UserExeImageData=On
MemoryRegionNXPolicy.UserDllImageBase=On
MemoryRegionNXPolicy.UserDllImageCode=On
MemoryRegionNXPolicy.UserDllImageData=On
MemoryRegionNXPolicy.UserForceRelocatedImageBase=On
MemoryRegionNXPolicy.UserForceRelocatedImageCode=On
MemoryRegionNXPolicy.UserForceRelocatedImageData=On
MemoryRegionNXPolicy.UserSharedUserData=On
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=On
UserHeapPolicy.HeapAllocationOrderRandomization=On
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=On
UserHeapPolicy.HeapBusyBlockIntegrityCheck=On
UserHeapPolicy.HeapSegmentReserveGuardPage=On
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=On
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Violation profile: w-bf-cc-df-ec

Method=Write
BaseState=Fixed
BaseRegionType=Stack
ContentSrcState=Controlled
ContentDstState=Unknown
ContentDataType=
ContentDataTypeName=
ContentContainerDataType=
ContentContainerTypeName=
DisplacementState=Fixed
DisplacementInitialOffset=PostAdjacent
ExtentState=Controlled
AddressingMode=Relative
Direction=Forward
ControlTransferMethod=
Address=
Locality=Unspecified
AccessRequirement=Unspecified
ExecutionDomain=Unspecified
CrashDumpFile=
SourceFile=
SourceLines=
TraceFile=
TracePositions=
FunctionStackProtectionEnabled=True
FunctionStackProtectionVersion=GS_VC10
FunctionStackProtectionEntropyBits=48
TransitiveExecuteListIsComplete=
TransitiveReadListIsComplete=
TransitiveWriteListIsComplete=




SIMULATIONS
-----------

===============

Simulation exploitability: 1.61558713389263E-27

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 3.5527136788005E-15 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 7.62939453125E-06 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 5.96046447753906E-08 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1.61558713389263E-27

Transitions

 w-bf-cc-df-ec                                      -> corrupt return address on stack     -> r-b?-cc-d?-e?
 r-b?-cc-d?-e?                                      -> return from function with corrupted return address -> x-bc-c?
 x-bc-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackProtectionCookie)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackReturnAddress)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackFramePointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddress(&Stack.StackStructuredExceptionHandlerFunctionPointer)
 [invariant                                         ] 1 = CanCorruptMemoryAtAddressListComplete
 [corrupt return address on stack                   ] 1 = CanTriggerMemoryRead
 [return from function with corrupted return address] 1 = CanReadMemoryAtAddress(&Stack.StackReturnAddress)
 [return from function with corrupted return address] 1 = CanTriggerFunctionReturn
 [return from function with corrupted return address] 3.5527136788005E-15 = CanDetermineStackProtectionCookie
 [return from function with corrupted return address] 1 = CanTriggerMemoryExecute
 [execute ROP (pure)                                ] 7.62939453125E-06 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 5.96046447753906E-08 = CanFindAddress(&Any.AttackerControlledData)
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode


Simulation finished, press any key.
=================================================
Simulating violation: r-bf-cu-df-ef [Use after free of C++ virtual table pointer]
Simulation graph has 21 edges
9 simulations recorded

CHARACTERISTICS
---------------

Exploitability(avg) = 0.66796875
Exploitability(max) = 1
Exploitability(min) = 0.00390625


CONFIGURATION
-------------

Hardware profile: x86/x86_pae

AddressBits=32
ArchitectureFamily=I386
NXPolicy=On
SMEPPolicy=NotSupported


OperatingSystem profile: windows/seven/rtm/32bit

UserSEHOPPolicy=OptIn
UserSafeSEHPolicy=On
UserASLRPolicyBottomUpHighEntropy=NotSupported
UserPointerEncodingUEF=True
UserPointerEncodingPEBFastLockRoutine=True
UserPointerEncodingHeapCommitRoutine=True
AddressBits=32
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC81
DefaultStackProtectionEntropyBits=32
KernelSMEPPolicy=NotSupported
KernelNullDereferencePreventionPolicy=NotSupported
KernelPoolPolicies.HeapFreeSafeUnlinking=On
KernelPoolPolicies.HeapTerminateOnCorruption=NotSupported
KernelPoolPolicies.HeapAllocationOrderRandomization=NotSupported
KernelPoolPolicies.HeapBlockHeaderCookies=NotSupported
KernelPoolPolicies.HeapBlockHeaderEncryption=NotSupported
KernelPoolPolicies.HeapPreventFreeHeapBase=NotSupported
KernelPoolPolicies.HeapBusyBlockIntegrityCheck=NotSupported
KernelPoolPolicies.HeapSegmentReserveGuardPage=NotSupported
KernelPoolPolicies.HeapLargeAllocationAlignment=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithPointerKey=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
KernelPoolPolicies.KernelPoolQuotaPointerEncoding=NotSupported
KernelPoolPolicies.KernelPoolLookasideListCookie=NotSupported
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=NotSupported
MemoryRegionNXPolicy.KernelNonPagedPool=NotSupported
MemoryRegionNXPolicy.KernelSessionPool=NotSupported
MemoryRegionNXPolicy.KernelPageTablePages=NotSupported
MemoryRegionNXPolicy.KernelDriverImage=NotSupported
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=NotSupported
MemoryRegionNXPolicy.KernelSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelSystemPTE=NotSupported
MemoryRegionNXPolicy.KernelSystemCache=NotSupported
MemoryRegionNXPolicy.KernelPFNDatabase=NotSupported
MemoryRegionNXPolicy.KernelHALReserved=NotSupported
MemoryRegionNXPolicy.UserProcessHeap=OptIn
MemoryRegionNXPolicy.UserThreadStack=OptIn
MemoryRegionNXPolicy.UserPEB=OptIn
MemoryRegionNXPolicy.UserTEB=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBU=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=OptIn
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=OptIn
MemoryRegionNXPolicy.UserExeImageCode=OptIn
MemoryRegionNXPolicy.UserExeImageData=OptIn
MemoryRegionNXPolicy.UserDllImageBase=OptIn
MemoryRegionNXPolicy.UserDllImageCode=OptIn
MemoryRegionNXPolicy.UserDllImageData=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageData=OptIn
MemoryRegionNXPolicy.UserSharedUserData=OptIn
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=OptIn
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=NotSupported
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=OptIn
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=OptIn
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionASLREntropyBits.KernelInitialThreadStack=0
MemoryRegionASLREntropyBits.KernelThreadStack=0
MemoryRegionASLREntropyBits.KernelPagedPool=0
MemoryRegionASLREntropyBits.KernelNonPagedPool=0
MemoryRegionASLREntropyBits.KernelSessionPool=0
MemoryRegionASLREntropyBits.KernelPageTablePages=0
MemoryRegionASLREntropyBits.KernelDriverImage=6
MemoryRegionASLREntropyBits.KernelExeImage=5
MemoryRegionASLREntropyBits.KernelHyperspace=0
MemoryRegionASLREntropyBits.KernelPCR=0
MemoryRegionASLREntropyBits.KernelSharedUserData=0
MemoryRegionASLREntropyBits.KernelSystemPTE=0
MemoryRegionASLREntropyBits.KernelSystemCache=0
MemoryRegionASLREntropyBits.KernelPFNDatabase=0
MemoryRegionASLREntropyBits.KernelHALReserved=0
MemoryRegionASLREntropyBits.UserProcessHeap=5
MemoryRegionASLREntropyBits.UserThreadStack=14
MemoryRegionASLREntropyBits.UserPEB=4
MemoryRegionASLREntropyBits.UserTEB=4
MemoryRegionASLREntropyBits.UserVirtualAllocBU=0
MemoryRegionASLREntropyBits.UserVirtualAllocBUHE=0
MemoryRegionASLREntropyBits.UserVirtualAllocTD=0
MemoryRegionASLREntropyBits.UserJITCode=0
MemoryRegionASLREntropyBits.UserExeImageBase=8
MemoryRegionASLREntropyBits.UserExeImageCode=8
MemoryRegionASLREntropyBits.UserExeImageData=8
MemoryRegionASLREntropyBits.UserDllImageBase=8
MemoryRegionASLREntropyBits.UserDllImageCode=8
MemoryRegionASLREntropyBits.UserDllImageData=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageBase=0
MemoryRegionASLREntropyBits.UserForceRelocatedImageCode=0
MemoryRegionASLREntropyBits.UserForceRelocatedImageData=0
MemoryRegionASLREntropyBits.UserSharedUserData=0
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=OptIn
UserHeapPolicy.HeapAllocationOrderRandomization=NotSupported
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=NotSupported
UserHeapPolicy.HeapBusyBlockIntegrityCheck=NotSupported
UserHeapPolicy.HeapSegmentReserveGuardPage=NotSupported
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=On
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Application profile: windows/ie/ie8/32bit

UserSEHOPPolicy=OptIn
UserASLRPolicyBottomUpHighEntropy=
AddressBits=32
KernelApplication=False
NXPermanent=
HeapAllocator=
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC81
DefaultStackProtectionEntropyBits=32
RestrictAutomaticRestarts=
CanInitializeContentViaHeapSpray=True
CanInitializeCodeViaJIT=False
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=On
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=NotSupported
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=On
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=On
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=NotSupported
MemoryRegionNXPolicy.KernelNonPagedPool=NotSupported
MemoryRegionNXPolicy.KernelSessionPool=NotSupported
MemoryRegionNXPolicy.KernelPageTablePages=NotSupported
MemoryRegionNXPolicy.KernelDriverImage=NotSupported
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=NotSupported
MemoryRegionNXPolicy.KernelSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelSystemPTE=NotSupported
MemoryRegionNXPolicy.KernelSystemCache=NotSupported
MemoryRegionNXPolicy.KernelPFNDatabase=NotSupported
MemoryRegionNXPolicy.KernelHALReserved=NotSupported
MemoryRegionNXPolicy.UserProcessHeap=On
MemoryRegionNXPolicy.UserThreadStack=On
MemoryRegionNXPolicy.UserPEB=On
MemoryRegionNXPolicy.UserTEB=On
MemoryRegionNXPolicy.UserVirtualAllocBU=On
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=On
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=On
MemoryRegionNXPolicy.UserExeImageCode=On
MemoryRegionNXPolicy.UserExeImageData=On
MemoryRegionNXPolicy.UserDllImageBase=On
MemoryRegionNXPolicy.UserDllImageCode=On
MemoryRegionNXPolicy.UserDllImageData=On
MemoryRegionNXPolicy.UserForceRelocatedImageBase=On
MemoryRegionNXPolicy.UserForceRelocatedImageCode=On
MemoryRegionNXPolicy.UserForceRelocatedImageData=On
MemoryRegionNXPolicy.UserSharedUserData=On
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=On
UserHeapPolicy.HeapAllocationOrderRandomization=NotSupported
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=NotSupported
UserHeapPolicy.HeapBusyBlockIntegrityCheck=NotSupported
UserHeapPolicy.HeapSegmentReserveGuardPage=NotSupported
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=On
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Violation profile: r-bf-cu-df-ef

Method=Read
BaseState=Fixed
BaseRegionType=Heap
ContentSrcState=Uninitialized
ContentDstState=Nonexistant
ContentDataType=CppVirtualTablePointer
ContentDataTypeName=
ContentContainerDataType=CppObject
ContentContainerTypeName=
DisplacementState=Fixed
DisplacementInitialOffset=
ExtentState=Fixed
AddressingMode=Absolute
Direction=
ControlTransferMethod=
Address=&Heap.CppVirtualTablePointer
Locality=Unspecified
AccessRequirement=Unspecified
ExecutionDomain=Unspecified
CrashDumpFile=
SourceFile=
SourceLines=
TraceFile=
TracePositions=
FunctionStackProtectionEnabled=True
FunctionStackProtectionVersion=GS_VC81
FunctionStackProtectionEntropyBits=32
TransitiveExecuteListIsComplete=
TransitiveReadListIsComplete=
TransitiveWriteListIsComplete=




SIMULATIONS
-----------

===============

Simulation exploitability: 1

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (pure)                                ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (pure)                                ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR image                 -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [load non-ASLR image                               ] 1 = CanLoadNonASLRImage
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 1

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> load non-ASLR and non-safeSEH image -> x-bc-cf
 x-bc-cf                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRImage
 [load non-ASLR and non-safeSEH image               ] 1 = CanLoadNonASLRNonSafeSEHImage
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [execute ROP (pure)                                ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to disable NX for process)     ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode


Simulation finished, press any key.
=================================================
Simulating violation: r-bf-cu-df-ef [Use after free of C++ virtual table pointer]
Simulation graph has 21 edges
3 simulations recorded

CHARACTERISTICS
---------------

Exploitability(avg) = 0.00390625
Exploitability(max) = 0.00390625
Exploitability(min) = 0.00390625


CONFIGURATION
-------------

Hardware profile: x86/x86_pae

AddressBits=32
ArchitectureFamily=I386
NXPolicy=On
SMEPPolicy=NotSupported


OperatingSystem profile: windows/eight/rtm/32bit

UserSEHOPPolicy=OptIn
UserSafeSEHPolicy=On
UserASLRPolicyBottomUpHighEntropy=OptIn
UserPointerEncodingUEF=True
UserPointerEncodingPEBFastLockRoutine=True
UserPointerEncodingHeapCommitRoutine=True
AddressBits=32
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC10
DefaultStackProtectionEntropyBits=32
KernelSMEPPolicy=Off
KernelNullDereferencePreventionPolicy=OptOut
KernelPoolPolicies.HeapFreeSafeUnlinking=On
KernelPoolPolicies.HeapTerminateOnCorruption=NotSupported
KernelPoolPolicies.HeapAllocationOrderRandomization=NotSupported
KernelPoolPolicies.HeapBlockHeaderCookies=NotSupported
KernelPoolPolicies.HeapBlockHeaderEncryption=NotSupported
KernelPoolPolicies.HeapPreventFreeHeapBase=NotSupported
KernelPoolPolicies.HeapBusyBlockIntegrityCheck=NotSupported
KernelPoolPolicies.HeapSegmentReserveGuardPage=NotSupported
KernelPoolPolicies.HeapLargeAllocationAlignment=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithPointerKey=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
KernelPoolPolicies.KernelPoolQuotaPointerEncoding=On
KernelPoolPolicies.KernelPoolLookasideListCookie=On
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=On
MemoryRegionNXPolicy.KernelNonPagedPool=On
MemoryRegionNXPolicy.KernelSessionPool=NotSupported
MemoryRegionNXPolicy.KernelPageTablePages=On
MemoryRegionNXPolicy.KernelDriverImage=NotSupported
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=On
MemoryRegionNXPolicy.KernelSharedUserData=On
MemoryRegionNXPolicy.KernelSystemPTE=On
MemoryRegionNXPolicy.KernelSystemCache=On
MemoryRegionNXPolicy.KernelPFNDatabase=On
MemoryRegionNXPolicy.KernelHALReserved=On
MemoryRegionNXPolicy.UserProcessHeap=OptIn
MemoryRegionNXPolicy.UserThreadStack=OptIn
MemoryRegionNXPolicy.UserPEB=OptIn
MemoryRegionNXPolicy.UserTEB=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBU=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=OptIn
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=OptIn
MemoryRegionNXPolicy.UserExeImageCode=OptIn
MemoryRegionNXPolicy.UserExeImageData=OptIn
MemoryRegionNXPolicy.UserDllImageBase=OptIn
MemoryRegionNXPolicy.UserDllImageCode=OptIn
MemoryRegionNXPolicy.UserDllImageData=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageData=OptIn
MemoryRegionNXPolicy.UserSharedUserData=OptIn
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=OptIn
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=OptIn
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=On
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=OptIn
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=OptIn
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionASLREntropyBits.KernelInitialThreadStack=0
MemoryRegionASLREntropyBits.KernelThreadStack=0
MemoryRegionASLREntropyBits.KernelPagedPool=0
MemoryRegionASLREntropyBits.KernelNonPagedPool=0
MemoryRegionASLREntropyBits.KernelSessionPool=0
MemoryRegionASLREntropyBits.KernelPageTablePages=0
MemoryRegionASLREntropyBits.KernelDriverImage=6
MemoryRegionASLREntropyBits.KernelExeImage=5
MemoryRegionASLREntropyBits.KernelHyperspace=0
MemoryRegionASLREntropyBits.KernelPCR=0
MemoryRegionASLREntropyBits.KernelSharedUserData=0
MemoryRegionASLREntropyBits.KernelSystemPTE=0
MemoryRegionASLREntropyBits.KernelSystemCache=0
MemoryRegionASLREntropyBits.KernelPFNDatabase=0
MemoryRegionASLREntropyBits.KernelHALReserved=0
MemoryRegionASLREntropyBits.UserProcessHeap=8
MemoryRegionASLREntropyBits.UserThreadStack=8
MemoryRegionASLREntropyBits.UserPEB=8
MemoryRegionASLREntropyBits.UserTEB=8
MemoryRegionASLREntropyBits.UserVirtualAllocBU=8
MemoryRegionASLREntropyBits.UserVirtualAllocBUHE=24
MemoryRegionASLREntropyBits.UserVirtualAllocTD=8
MemoryRegionASLREntropyBits.UserJITCode=8
MemoryRegionASLREntropyBits.UserExeImageBase=8
MemoryRegionASLREntropyBits.UserExeImageCode=8
MemoryRegionASLREntropyBits.UserExeImageData=8
MemoryRegionASLREntropyBits.UserDllImageBase=8
MemoryRegionASLREntropyBits.UserDllImageCode=8
MemoryRegionASLREntropyBits.UserDllImageData=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageBase=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageCode=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageData=8
MemoryRegionASLREntropyBits.UserSharedUserData=0
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=OptIn
UserHeapPolicy.HeapAllocationOrderRandomization=On
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=On
UserHeapPolicy.HeapBusyBlockIntegrityCheck=On
UserHeapPolicy.HeapSegmentReserveGuardPage=On
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=On
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Application profile: windows/ie/ie9/32bit

UserSEHOPPolicy=On
UserASLRPolicyBottomUpHighEntropy=
AddressBits=32
KernelApplication=False
NXPermanent=
HeapAllocator=
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC10
DefaultStackProtectionEntropyBits=32
RestrictAutomaticRestarts=
CanInitializeContentViaHeapSpray=True
CanInitializeCodeViaJIT=False
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=On
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=On
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=On
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=On
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=On
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=On
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=On
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=On
MemoryRegionNXPolicy.KernelNonPagedPool=On
MemoryRegionNXPolicy.KernelSessionPool=NotSupported
MemoryRegionNXPolicy.KernelPageTablePages=On
MemoryRegionNXPolicy.KernelDriverImage=NotSupported
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=On
MemoryRegionNXPolicy.KernelSharedUserData=On
MemoryRegionNXPolicy.KernelSystemPTE=On
MemoryRegionNXPolicy.KernelSystemCache=On
MemoryRegionNXPolicy.KernelPFNDatabase=On
MemoryRegionNXPolicy.KernelHALReserved=On
MemoryRegionNXPolicy.UserProcessHeap=On
MemoryRegionNXPolicy.UserThreadStack=On
MemoryRegionNXPolicy.UserPEB=On
MemoryRegionNXPolicy.UserTEB=On
MemoryRegionNXPolicy.UserVirtualAllocBU=On
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=On
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=On
MemoryRegionNXPolicy.UserExeImageCode=On
MemoryRegionNXPolicy.UserExeImageData=On
MemoryRegionNXPolicy.UserDllImageBase=On
MemoryRegionNXPolicy.UserDllImageCode=On
MemoryRegionNXPolicy.UserDllImageData=On
MemoryRegionNXPolicy.UserForceRelocatedImageBase=On
MemoryRegionNXPolicy.UserForceRelocatedImageCode=On
MemoryRegionNXPolicy.UserForceRelocatedImageData=On
MemoryRegionNXPolicy.UserSharedUserData=On
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=On
UserHeapPolicy.HeapAllocationOrderRandomization=On
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=On
UserHeapPolicy.HeapBusyBlockIntegrityCheck=On
UserHeapPolicy.HeapSegmentReserveGuardPage=On
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=On
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Violation profile: r-bf-cu-df-ef

Method=Read
BaseState=Fixed
BaseRegionType=Heap
ContentSrcState=Uninitialized
ContentDstState=Nonexistant
ContentDataType=CppVirtualTablePointer
ContentDataTypeName=
ContentContainerDataType=CppObject
ContentContainerTypeName=
DisplacementState=Fixed
DisplacementInitialOffset=
ExtentState=Fixed
AddressingMode=Absolute
Direction=
ControlTransferMethod=
Address=&Heap.CppVirtualTablePointer
Locality=Unspecified
AccessRequirement=Unspecified
ExecutionDomain=Unspecified
CrashDumpFile=
SourceFile=
SourceLines=
TraceFile=
TracePositions=
FunctionStackProtectionEnabled=True
FunctionStackProtectionVersion=GS_VC10
FunctionStackProtectionEntropyBits=32
TransitiveExecuteListIsComplete=
TransitiveReadListIsComplete=
TransitiveWriteListIsComplete=




SIMULATIONS
-----------

===============

Simulation exploitability: 0.00390625

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to VirtualProtect/VirtualAlloc) -> x-bc-cc

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanPivotStackPointer
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanProtectDataAsCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteControlledCode
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanBypassNX
 [execute ROP (stage to VirtualProtect/VirtualAlloc)] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> execute ROP (pure)                  -> x-bc-cf

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [execute ROP (pure)                                ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (pure)                                ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (pure)                                ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (pure)                                ] 1 = CanPivotStackPointer
 [execute ROP (pure)                                ] 1 = CanExecuteCode
 [execute ROP (pure)                                ] 1 = CanBypassNX
 [execute ROP (pure)                                ] 1 = CanExecuteDesiredCode

===============

Simulation exploitability: 0.00390625

Transitions

 r-bf-cu-df-ef                                      -> heap spray content to init src &Heap.CppVirtualTablePointer -> r-bf-cc-df-ef
 r-bf-cc-df-ef                                      -> read virtual table pointer from C++ object stored in Heap -> r-bc-c?-d?-e?
 r-bc-c?-d?-e?                                      -> heap spray content to init src &Any.CppVirtualTable -> r-bc-cc-d?-e?
 r-bc-cc-d?-e?                                      -> call virtual method via virtual table -> x-bc-c?
 x-bc-c?                                            -> execute ROP (stage to disable NX for process) -> x-bc-c?
 x-bc-c?                                            -> execute attacker controlled data as code -> x-bc-cc

Assumptions

 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanReadMemoryAtAddress(&Heap.CppVirtualTablePointer)
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanInitializeContentViaHeapSpray
 [heap spray content to init src &Heap.CppVirtualTablePointer] 1 = CanFindAddress(&Any.AttackerControlledData)
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerVirtualMethodCall
 [read virtual table pointer from C++ object stored in Heap] 1 = CanTriggerMemoryRead
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanPositionAtDesiredAbsoluteAddress(&Any.CppVirtualTable)
 [heap spray content to init src &Any.CppVirtualTable] 1 = CanReadMemoryAtAddress(&Any.CppVirtualTable)
 [call virtual method via virtual table             ] 1 = CanTriggerMemoryExecute
 [execute ROP (stage to disable NX for process)     ] 0.00390625 = CanFindAddress(&ImageCodeSegment.Code)
 [execute ROP (stage to disable NX for process)     ] 1 = IsROPGadgetImageVersionKnown
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindRequiredROPGadgetsInImageCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanPivotStackPointer
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteCode
 [execute ROP (stage to disable NX for process)     ] 1 = CanExecuteData
 [execute ROP (stage to disable NX for process)     ] 1 = CanFindAddress(&Any.AttackerControlledCode)
 [execute ROP (stage to disable NX for process)     ] 1 = CanBypassNX
 [execute attacker controlled data as code          ] 1 = CanExecuteControlledCode
 [execute attacker controlled data as code          ] 1 = CanExecuteDesiredCode


Simulation finished, press any key.
=================================================
Simulating violation: r-bf-cu-df-ef [Use after free of C++ virtual table pointer]
Simulation graph has 21 edges
0 simulations recorded

CHARACTERISTICS
---------------


CONFIGURATION
-------------

Hardware profile: x86/x86_pae

AddressBits=32
ArchitectureFamily=I386
NXPolicy=On
SMEPPolicy=NotSupported


OperatingSystem profile: windows/eight/rtm/64bit

UserSEHOPPolicy=OptIn
UserSafeSEHPolicy=On
UserASLRPolicyBottomUpHighEntropy=OptIn
UserPointerEncodingUEF=True
UserPointerEncodingPEBFastLockRoutine=True
UserPointerEncodingHeapCommitRoutine=True
AddressBits=64
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC10
DefaultStackProtectionEntropyBits=48
KernelSMEPPolicy=Off
KernelNullDereferencePreventionPolicy=OptOut
KernelPoolPolicies.HeapFreeSafeUnlinking=On
KernelPoolPolicies.HeapTerminateOnCorruption=NotSupported
KernelPoolPolicies.HeapAllocationOrderRandomization=NotSupported
KernelPoolPolicies.HeapBlockHeaderCookies=NotSupported
KernelPoolPolicies.HeapBlockHeaderEncryption=NotSupported
KernelPoolPolicies.HeapPreventFreeHeapBase=NotSupported
KernelPoolPolicies.HeapBusyBlockIntegrityCheck=NotSupported
KernelPoolPolicies.HeapSegmentReserveGuardPage=NotSupported
KernelPoolPolicies.HeapLargeAllocationAlignment=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithPointerKey=NotSupported
KernelPoolPolicies.HeapEncodeCommitRoutineWithGlobalKey=NotSupported
KernelPoolPolicies.KernelPoolQuotaPointerEncoding=On
KernelPoolPolicies.KernelPoolLookasideListCookie=On
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=On
MemoryRegionNXPolicy.KernelNonPagedPool=On
MemoryRegionNXPolicy.KernelSessionPool=On
MemoryRegionNXPolicy.KernelPageTablePages=On
MemoryRegionNXPolicy.KernelDriverImage=On
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=On
MemoryRegionNXPolicy.KernelSharedUserData=On
MemoryRegionNXPolicy.KernelSystemPTE=On
MemoryRegionNXPolicy.KernelSystemCache=On
MemoryRegionNXPolicy.KernelPFNDatabase=On
MemoryRegionNXPolicy.KernelHALReserved=On
MemoryRegionNXPolicy.UserProcessHeap=OptIn
MemoryRegionNXPolicy.UserThreadStack=OptIn
MemoryRegionNXPolicy.UserPEB=OptIn
MemoryRegionNXPolicy.UserTEB=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBU=OptIn
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=OptIn
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=OptIn
MemoryRegionNXPolicy.UserExeImageCode=OptIn
MemoryRegionNXPolicy.UserExeImageData=OptIn
MemoryRegionNXPolicy.UserDllImageBase=OptIn
MemoryRegionNXPolicy.UserDllImageCode=OptIn
MemoryRegionNXPolicy.UserDllImageData=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionNXPolicy.UserForceRelocatedImageData=OptIn
MemoryRegionNXPolicy.UserSharedUserData=OptIn
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=OptIn
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=OptIn
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=On
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=OptIn
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=OptIn
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=OptIn
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=OptIn
MemoryRegionASLRPolicy.UserForceRelocatedImageData=NotSupported
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionASLREntropyBits.KernelInitialThreadStack=0
MemoryRegionASLREntropyBits.KernelThreadStack=0
MemoryRegionASLREntropyBits.KernelPagedPool=0
MemoryRegionASLREntropyBits.KernelNonPagedPool=0
MemoryRegionASLREntropyBits.KernelSessionPool=0
MemoryRegionASLREntropyBits.KernelPageTablePages=0
MemoryRegionASLREntropyBits.KernelDriverImage=8
MemoryRegionASLREntropyBits.KernelExeImage=5
MemoryRegionASLREntropyBits.KernelHyperspace=0
MemoryRegionASLREntropyBits.KernelPCR=0
MemoryRegionASLREntropyBits.KernelSharedUserData=0
MemoryRegionASLREntropyBits.KernelSystemPTE=0
MemoryRegionASLREntropyBits.KernelSystemCache=0
MemoryRegionASLREntropyBits.KernelPFNDatabase=0
MemoryRegionASLREntropyBits.KernelHALReserved=0
MemoryRegionASLREntropyBits.UserProcessHeap=24
MemoryRegionASLREntropyBits.UserThreadStack=33
MemoryRegionASLREntropyBits.UserPEB=17
MemoryRegionASLREntropyBits.UserTEB=17
MemoryRegionASLREntropyBits.UserVirtualAllocBU=24
MemoryRegionASLREntropyBits.UserVirtualAllocBUHE=24
MemoryRegionASLREntropyBits.UserVirtualAllocTD=17
MemoryRegionASLREntropyBits.UserJITCode=24
MemoryRegionASLREntropyBits.UserExeImageBase=17
MemoryRegionASLREntropyBits.UserExeImageCode=8
MemoryRegionASLREntropyBits.UserExeImageData=8
MemoryRegionASLREntropyBits.UserDllImageBase=19
MemoryRegionASLREntropyBits.UserDllImageCode=8
MemoryRegionASLREntropyBits.UserDllImageData=8
MemoryRegionASLREntropyBits.UserForceRelocatedImageBase=24
MemoryRegionASLREntropyBits.UserForceRelocatedImageCode=24
MemoryRegionASLREntropyBits.UserForceRelocatedImageData=24
MemoryRegionASLREntropyBits.UserSharedUserData=0
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=OptOut
UserHeapPolicy.HeapAllocationOrderRandomization=On
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=On
UserHeapPolicy.HeapBusyBlockIntegrityCheck=On
UserHeapPolicy.HeapSegmentReserveGuardPage=On
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=On
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Application profile: windows/ie/ie10/64bit

UserSEHOPPolicy=OptIn
UserASLRPolicyBottomUpHighEntropy=On
AddressBits=64
KernelApplication=False
NXPermanent=
HeapAllocator=
DefaultStackProtectionEnabled=True
DefaultStackProtectionVersion=GS_VC10
DefaultStackProtectionEntropyBits=48
RestrictAutomaticRestarts=
CanInitializeContentViaHeapSpray=False
CanInitializeCodeViaJIT=False
MemoryRegionASLRPolicy.KernelInitialThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelThreadStack=NotSupported
MemoryRegionASLRPolicy.KernelPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelNonPagedPool=NotSupported
MemoryRegionASLRPolicy.KernelSessionPool=NotSupported
MemoryRegionASLRPolicy.KernelPageTablePages=NotSupported
MemoryRegionASLRPolicy.KernelDriverImage=On
MemoryRegionASLRPolicy.KernelExeImage=On
MemoryRegionASLRPolicy.KernelHyperspace=NotSupported
MemoryRegionASLRPolicy.KernelPCR=NotSupported
MemoryRegionASLRPolicy.KernelSharedUserData=NotSupported
MemoryRegionASLRPolicy.KernelSystemPTE=NotSupported
MemoryRegionASLRPolicy.KernelSystemCache=NotSupported
MemoryRegionASLRPolicy.KernelPFNDatabase=NotSupported
MemoryRegionASLRPolicy.KernelHALReserved=NotSupported
MemoryRegionASLRPolicy.UserProcessHeap=On
MemoryRegionASLRPolicy.UserThreadStack=On
MemoryRegionASLRPolicy.UserPEB=On
MemoryRegionASLRPolicy.UserTEB=On
MemoryRegionASLRPolicy.UserVirtualAllocBU=On
MemoryRegionASLRPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionASLRPolicy.UserVirtualAllocTD=On
MemoryRegionASLRPolicy.UserJITCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageBase=On
MemoryRegionASLRPolicy.UserExeImageCode=NotSupported
MemoryRegionASLRPolicy.UserExeImageData=NotSupported
MemoryRegionASLRPolicy.UserDllImageBase=On
MemoryRegionASLRPolicy.UserDllImageCode=NotSupported
MemoryRegionASLRPolicy.UserDllImageData=NotSupported
MemoryRegionASLRPolicy.UserForceRelocatedImageBase=On
MemoryRegionASLRPolicy.UserForceRelocatedImageCode=On
MemoryRegionASLRPolicy.UserForceRelocatedImageData=On
MemoryRegionASLRPolicy.UserSharedUserData=NotSupported
MemoryRegionNXPolicy.KernelInitialThreadStack=On
MemoryRegionNXPolicy.KernelThreadStack=On
MemoryRegionNXPolicy.KernelPagedPool=On
MemoryRegionNXPolicy.KernelNonPagedPool=On
MemoryRegionNXPolicy.KernelSessionPool=On
MemoryRegionNXPolicy.KernelPageTablePages=On
MemoryRegionNXPolicy.KernelDriverImage=On
MemoryRegionNXPolicy.KernelExeImage=NotSupported
MemoryRegionNXPolicy.KernelHyperspace=On
MemoryRegionNXPolicy.KernelPCR=On
MemoryRegionNXPolicy.KernelSharedUserData=On
MemoryRegionNXPolicy.KernelSystemPTE=On
MemoryRegionNXPolicy.KernelSystemCache=On
MemoryRegionNXPolicy.KernelPFNDatabase=On
MemoryRegionNXPolicy.KernelHALReserved=On
MemoryRegionNXPolicy.UserProcessHeap=On
MemoryRegionNXPolicy.UserThreadStack=On
MemoryRegionNXPolicy.UserPEB=On
MemoryRegionNXPolicy.UserTEB=On
MemoryRegionNXPolicy.UserVirtualAllocBU=On
MemoryRegionNXPolicy.UserVirtualAllocBUHE=NotSupported
MemoryRegionNXPolicy.UserVirtualAllocTD=On
MemoryRegionNXPolicy.UserJITCode=NotSupported
MemoryRegionNXPolicy.UserExeImageBase=On
MemoryRegionNXPolicy.UserExeImageCode=On
MemoryRegionNXPolicy.UserExeImageData=On
MemoryRegionNXPolicy.UserDllImageBase=On
MemoryRegionNXPolicy.UserDllImageCode=On
MemoryRegionNXPolicy.UserDllImageData=On
MemoryRegionNXPolicy.UserForceRelocatedImageBase=On
MemoryRegionNXPolicy.UserForceRelocatedImageCode=On
MemoryRegionNXPolicy.UserForceRelocatedImageData=On
MemoryRegionNXPolicy.UserSharedUserData=On
UserHeapPolicy.HeapFreeSafeUnlinking=On
UserHeapPolicy.HeapTerminateOnCorruption=On
UserHeapPolicy.HeapAllocationOrderRandomization=On
UserHeapPolicy.HeapBlockHeaderCookies=On
UserHeapPolicy.HeapBlockHeaderEncryption=On
UserHeapPolicy.HeapPreventFreeHeapBase=On
UserHeapPolicy.HeapBusyBlockIntegrityCheck=On
UserHeapPolicy.HeapSegmentReserveGuardPage=On
UserHeapPolicy.HeapLargeAllocationAlignment=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithPointerKey=NotSupported
UserHeapPolicy.HeapEncodeCommitRoutineWithGlobalKey=On
UserHeapPolicy.KernelPoolQuotaPointerEncoding=NotSupported
UserHeapPolicy.KernelPoolLookasideListCookie=NotSupported


Violation profile: r-bf-cu-df-ef

Method=Read
BaseState=Fixed
BaseRegionType=Heap
ContentSrcState=Uninitialized
ContentDstState=Nonexistant
ContentDataType=CppVirtualTablePointer
ContentDataTypeName=
ContentContainerDataType=CppObject
ContentContainerTypeName=
DisplacementState=Fixed
DisplacementInitialOffset=
ExtentState=Fixed
AddressingMode=Absolute
Direction=
ControlTransferMethod=
Address=&Heap.CppVirtualTablePointer
Locality=Unspecified
AccessRequirement=Unspecified
ExecutionDomain=Unspecified
CrashDumpFile=
SourceFile=
SourceLines=
TraceFile=
TracePositions=
FunctionStackProtectionEnabled=True
FunctionStackProtectionVersion=GS_VC10
FunctionStackProtectionEntropyBits=48
TransitiveExecuteListIsComplete=
TransitiveReadListIsComplete=
TransitiveWriteListIsComplete=




SIMULATIONS
-----------


Simulation finished, press any key.
